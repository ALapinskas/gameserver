<!DOCTYPE html>
<head>
    <title>Tic-Tac-Toe game app</title>
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, user-scalable=0, minimum-scale=1.0, maximum-scale=1.0">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.5.0/socket.io.js"></script>
    <script type="module" src="/node_modules/uikit/dist/uikit.min.js"></script>
</head>
<body>
    <div class="controls">
        <div id="whoseTurn"></div>
        <button id="apply" disabled>Apply turn</button>
    </div>
    <div id="board">
        
    </div>
    <script>
        document.onreadystatechange = function () {
            if (document.readyState == "complete") {
                const applyButton = document.getElementById("apply");
                let popup = window.uikit.Popup,
                    formSwitcher = window.uikit.FormSwitchers,
                    formInput = window.uikit.FormInput,
                    roomValue,
                    playOptions = { 
                        SINGLE: "Single Player",
                        MULTIPLAYER: "Two Players"
                    },
                    socket,
                    isCreator = false,
                    applicationState = { whoseTurn:undefined, playerA:{turns:[]}, playerB:{turns:[]} },
                    gameBoard,
                    boardOverlay,
                    loadingPopup = undefined,
                    whoseTurnPopup = undefined,
                    ctxBoard,
                    ctxOverlay,
                    curX,
                    curY,
                    pressed = false,
                    selectedCell,
                    currentTurn = {};

                let popupContents = function() {
                    let wrapper = document.createElement('div'),
                        header = document.createElement('h1'),
                        howManyPlayers = new formSwitcher(
                            "howManyPlayers", 
                            "How many players?",
                            "radio",
                            "howMany",
                            Object.keys(playOptions).map((key) => playOptions[key])
                        ),
                        roomName = new formInput("name", "Room Name"),
                        submitButton = document.createElement("button");
                    header.innerText = "Tic-tac-toe";
                    submitButton.innerText = "Play!";
                    wrapper.style.padding = "10px";
                    howManyPlayers.wrapper.style["padding-bottom"] = "15px";
                    roomName.wrapper.style.display = "block";
                    roomName.wrapper.style["padding-bottom"] = "15px";

                    wrapper.appendChild(header);
                    wrapper.appendChild(howManyPlayers.wrapper);
                    wrapper.appendChild(roomName.wrapper);
                    howManyPlayers.values = ["Two Players"];
                    howManyPlayers.on("change", e => {
                        console.log("changed radio: ", e.target.value);
                        if (e.target.value === playOptions.SINGLE) {
                            roomName.wrapper.style.display = "none";
                        } else {
                            roomName.wrapper.style.display = "block";
                        }
                    });

                    submitButton.addEventListener("click", () => {
                        const value = howManyPlayers.values[0];
                        if(value === playOptions.SINGLE) {
                            alert("Sorry, single player game is not implemented yet! \n please choose Multiplayer one, \n and call a friend to play with you!");
                        } else {
                            if(roomName.value.trim().length === 0) {
                                alert("please type a room name to play!");
                            } else {
                                console.log("play");
                                roomValue = roomName.value.trim();
                                socket = io("http://localhost:9000", {withCredentials: true});
                                socket.on("created", (room, map) => {
                                    console.log("room created! Waiting for other player...");
                                    optionsPopup.close();
                                    loadingPopup = new popup("loading", loadingContents(), true);
                                    isCreator = true;
                                });
                                socket.on("joined", (room, map) => {
                                    console.log("some body joined! Starting the game!");
                                    optionsPopup.close();
                                    applicationState = map;
                                    if(loadingPopup) loadingPopup.close();
                                    console.log("whose turn: ", applicationState.whoseTurn);
                                    if(typeof applicationState.whoseTurn === "undefined") {
                                        whoseTurnPopup = new popup("whoseTurn", whoseTurnContents(), true);
                                    }
                                });
                                socket.on("log", (message) => {
                                    console.log("log from server: ", message);
                                });
                                socket.on("full", (message) => {
                                    alert("Sorry, this room is overflowed, choose another one");
                                });
                                socket.on("message", (message) => {
                                    console.log("message from server: ", message);
                                    switch(message.type) {
                                        case "who_first":
                                            if(!isCreator) { 
                                                applicationState.whoseTurn = message.whoseTurn;
                                                applicationState.playerA.type = message.whoseTurn == 1 ? "cross" : "circle";
                                                applicationState.playerB.type = message.whoseTurn == 1 ? "circle" : "cross";
                                                console.log("Player " + message.whoseTurn + ", will be first!");
                                                if(loadingPopup) loadingPopup.close();
                                                drawBoard(applicationState.whoseTurn);
                                                setTimeout(() => whoseTurnPopup.close(), 2000);
                                            }
                                        break;
                                        case "turn_pass": 
                                            console.log("received message from opponent!");
                                            console.log("new app state: ");
                                            console.log(applicationState);
                                            applicationState = message.state;
                                            drawDoneTurns()
                                            writeWhoseTurnMessage(applicationState.whoseTurn);
                                    }
                                });
                                
                                socket.emit('create or join', roomValue, applicationState);
                            }
                        }
                    });

                    wrapper.appendChild(submitButton);
                    return wrapper;
                }
                const loadingContents = () => {
                    let wrapper = document.createElement("div"),
                        text = document.createElement("p");
                    wrapper.innerHTML = '<iframe src="https://upload.wikimedia.org/wikipedia/commons/b/b1/Loading_icon.gif" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>';
                    text.innerText = ("Waiting other player to join, please ask your friend to go to the address: " + window.location + ", and join the room: " + roomValue);
                    wrapper.appendChild(text);
                    wrapper.style.padding = "10px";
                    return wrapper;
                }
                const whoseTurnContents = () => {
                    let wrapper = document.createElement("div"),
                        text = document.createElement("p");
                    wrapper.innerHTML = '<iframe src="https://upload.wikimedia.org/wikipedia/commons/b/b1/Loading_icon.gif" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>';
                    text.innerText = ("Randomly choosing first player turn.");
                    if(isCreator) {
                        setTimeout(() => {
                            let player = ~~(Math.random() * 2) + 1;
                            console.log("Player ", player, " will be first!");
                            applicationState.playerA.type = player === 1 ? "cross" : "circle";
                            applicationState.playerB.type = player === 1 ? "circle" : "cross";
                            applicationState.whoseTurn = player;
                            socket.emit("message", {type:"who_first", whoseTurn: player});
                            drawBoard(player);
                            if(whoseTurnPopup) {
                                whoseTurnPopup.close();
                            }
                        }, 3000);
                    }
                    return wrapper;
                }

                const optionsPopup = new popup("default", popupContents(), true);  

                const drawBoard = (player) => {
                    const windowWidth = window.innerWidth,
                        windowHeight = window.innerHeight,
                        boardDiv = document.getElementById("board");

                    let boardWidth = windowWidth,
                        cellWidth = boardWidth / 3;

                    console.log("draw board");

                    writeWhoseTurnMessage(player);
                    
                    gameBoard = document.createElement("canvas");
                    turnsOverlay = document.createElement("canvas");
                    boardOverlay = document.createElement("canvas");

                    ctxBoard = gameBoard.getContext("2d");
                    ctxTurnsOverlay = turnsOverlay.getContext("2d");
                    ctxOverlay = boardOverlay.getContext("2d");
                    
                    gameBoard.id = "GameBoard";
                    turnsOverlay.id = "TurnsOverlay";
                    boardOverlay.id = "BoardOverlay";

                    if (windowWidth > windowHeight) {
                        while (boardWidth > windowHeight) {
                            boardWidth = windowWidth / 2;
                        }
                    } else {
                        boardWidth = windowHeight;
                        while (boardWidth > windowWidth) {
                            boardWidth = windowHeight / 2;
                        }
                    }

                    cellWidth = boardWidth / 3
                    gameBoard.width = boardWidth;
                    gameBoard.height = boardWidth;

                    gameBoard.style.position = "absolute";
                    gameBoard.style.left = "25%";
                    gameBoard.style.top = "25%";

                    boardOverlay.width = boardWidth;
                    boardOverlay.height = boardWidth;

                    boardOverlay.style.position = "absolute";
                    boardOverlay.style.left = "25%";
                    boardOverlay.style.top = "25%";

                    turnsOverlay.width = boardWidth;
                    turnsOverlay.height = boardWidth;

                    turnsOverlay.style.position = "absolute";
                    turnsOverlay.style.left = "25%";
                    turnsOverlay.style.top = "25%";

                    ctxBoard.fillStyle = "rgba(255, 255, 255, 0.3)";
                    ctxOverlay.fillStyle = "rgba(0, 0, 0, 0)"; 
                    ctxBoard.fillRect(0, 0, boardWidth, boardWidth);
                    ctxOverlay.fillRect(0, 0, boardWidth, boardWidth);


                    ctxBoard.strokeStyle = 'black';
                    ctxBoard.lineWidth = 5;

                    // draw a red line
                    ctxBoard.beginPath();
                    ctxBoard.moveTo(boardWidth/3, 0);
                    ctxBoard.lineTo(boardWidth/3, boardWidth);
                    ctxBoard.stroke();

                    ctxBoard.beginPath();
                    ctxBoard.moveTo(boardWidth/3 * 2, 0);
                    ctxBoard.lineTo(boardWidth/3 * 2, boardWidth);
                    ctxBoard.stroke();

                    ctxBoard.beginPath();
                    ctxBoard.moveTo(0, boardWidth/3);
                    ctxBoard.lineTo(boardWidth, boardWidth/3);
                    ctxBoard.stroke();

                    ctxBoard.beginPath();
                    ctxBoard.moveTo(0, boardWidth/3 * 2);
                    ctxBoard.lineTo(boardWidth, boardWidth/3 * 2);
                    ctxBoard.stroke();

                    boardDiv.appendChild(gameBoard);
                    boardDiv.appendChild(turnsOverlay);
                    boardDiv.appendChild(boardOverlay);

                    //setDrawEvents();

                    boardDiv.addEventListener("mousemove",  (e) => {
                        const x = e.offsetX,
    		                y = e.offsetY,
                            hoveredCellX = x > cellWidth ? x > (cellWidth * 2) ? 2 : 1 : 0,
                            hoveredCellY = y > cellWidth ? y > (cellWidth * 2) ? 2 : 1 : 0;
                        if (!isCellAlreadyOccupied(hoveredCellX, hoveredCellY)) {
                            ctxOverlay.clearRect(0, 0, boardOverlay.width, boardOverlay.height);
                            ctxOverlay.fillStyle = "rgba(189, 195, 199, 0.5)";
                            ctxOverlay.fillRect(hoveredCellX * cellWidth, hoveredCellY * cellWidth, cellWidth, cellWidth);
                        }
                    });

                    boardDiv.addEventListener("click",  (e) => {
                        const x = e.offsetX,
    		                y = e.offsetY,
                            clickedCellX = x > cellWidth ? x > (cellWidth * 2) ? 2 : 1 : 0,
                            clickedCellY = y > cellWidth ? y > (cellWidth * 2) ? 2 : 1 : 0;

                        let drawType;
                        console.log("clicked, application turn is by creator ?" , isCreator);
                        
                        if (whoseTurn(applicationState.whoseTurn) === "Its is your opponent turn") {
                            message("Its is your opponent turn now! Please wait...");
                        } else if (!isCellAlreadyOccupied(clickedCellX, clickedCellY)) {
                            if(isCreator && applicationState.whoseTurn === 1) {
                                drawType = applicationState.playerA.type;
                            } else if (!isCreator && applicationState.whoseTurn === 2) {
                                drawType = applicationState.playerB.type;
                            }
                            console.log("now it is turn: ", drawType);
                            ctxTurnsOverlay.clearRect(0, 0, boardOverlay.width, boardOverlay.height);
                            drawSign(drawType, clickedCellX, clickedCellY);
                            drawDoneTurns();
                            applyButton.disabled = false;
                        }
                    });

                    drawSign = (drawType, clickedCellX, clickedCellY) => {
                        console.log("draw: ", drawType, " ", clickedCellX, " ", clickedCellY);
                        if(drawType === "circle") {
                            const centerX = clickedCellX * cellWidth + (cellWidth/2);
                            const centerY = clickedCellY * cellWidth + (cellWidth/2);
                            const radius = cellWidth/2 - 20;

                            ctxTurnsOverlay.beginPath();
                            ctxTurnsOverlay.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);
                            //ctxTurnsOverlay.fillStyle = 'transparent';
                            //ctxTurnsOverlay.fill();
                            ctxTurnsOverlay.lineWidth = 5;
                            ctxTurnsOverlay.stroke();
                            currentTurn = { player: 2, x:clickedCellX, y: clickedCellY };
                        } else {
                            const padding = 30,
                                firstLineCordsA = {x: clickedCellX * cellWidth + padding, y: clickedCellY * cellWidth + padding},
                                firstLineCordsB = {x: clickedCellX * cellWidth + cellWidth - padding, y: clickedCellY * cellWidth + cellWidth - padding},
                                secondLineCordsA = {x: clickedCellX * cellWidth  + cellWidth - padding, y: clickedCellY * cellWidth + padding},
                                secondLineCordsB = {x: clickedCellX * cellWidth + padding, y: clickedCellY * cellWidth + cellWidth - padding};

                            ctxTurnsOverlay.beginPath();
                            ctxTurnsOverlay.moveTo(firstLineCordsA.x, firstLineCordsA.y);
                            ctxTurnsOverlay.lineTo(firstLineCordsB.x, firstLineCordsB.y);
                            ctxTurnsOverlay.lineWidth = 5;
                            ctxTurnsOverlay.stroke();
                            
                            ctxTurnsOverlay.beginPath();
                            ctxTurnsOverlay.moveTo(secondLineCordsA.x, secondLineCordsA.y);
                            ctxTurnsOverlay.lineTo(secondLineCordsB.x, secondLineCordsB.y);
                            ctxTurnsOverlay.lineWidth = 5;
                            ctxTurnsOverlay.stroke();
                            currentTurn = { player: 1, x:clickedCellX, y: clickedCellY };
                        }

                    }
                }

                const drawDoneTurns = () => {
                    applicationState.playerA.turns.forEach((turn) => {
                        drawSign(applicationState.playerA.type, turn.x, turn.y);
                    });
                    applicationState.playerB.turns.forEach((turn) => {
                        drawSign(applicationState.playerB.type, turn.x, turn.y);
                    });
                }

                const isCellAlreadyOccupied = (x, y) => {
                    let isOccupied = false;
                    applicationState.playerA.turns.forEach((turn) => {
                        if (turn.x === x && turn.y === y) {
                            isOccupied = true;
                        }
                    });
                    applicationState.playerB.turns.forEach((turn) => {
                        if (turn.x === x && turn.y === y) {
                            isOccupied = true;
                        }
                    });
                    return isOccupied;
                }

                applyButton.addEventListener("click", () => {
                    console.log("pass turn to other player");
                    if(currentTurn.player === 1) {
                        if(applicationState.playerA.type === "cross") {
                            applicationState.playerA.turns.push({x:currentTurn.x, y:currentTurn.y});
                        } else {
                            applicationState.playerB.turns.push({x:currentTurn.x, y:currentTurn.y});
                        }
                    } else {
                        if(applicationState.playerA.type === "circle") {
                            applicationState.playerA.turns.push({x:currentTurn.x, y:currentTurn.y});
                        } else {
                            applicationState.playerB.turns.push({x:currentTurn.x, y:currentTurn.y});
                        }
                    }
                    applicationState.whoseTurn = applicationState.whoseTurn === 1 ? 2 : 1;
                    console.log(applicationState);
                    socket.emit("message", {type:"turn_pass", state: applicationState});
                    applyButton.disabled = true;
                    writeWhoseTurnMessage(applicationState.whoseTurn);
                });

                function whoseTurn (player) {
                    if (typeof player !== "number") {
                        console.error("wrong type on whose turn check!");
                    }
                    return player == 1 ? isCreator ? "Its your turn now" : "Its is your opponent turn" : isCreator ? "Its is your opponent turn" : "Its your turn now"; 
                }

                function writeWhoseTurnMessage(player) {
                    const whoseTurnDiv = document.getElementById("whoseTurn");

                    whoseTurnDiv.innerText = whoseTurn(player);
                } 

                function message (message) {
                    alert(message);
                }
            }
        }
    </script>
</body>