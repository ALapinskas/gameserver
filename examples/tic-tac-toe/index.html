<!DOCTYPE html>
<head>
    <title>Tic-Tac-Toe game app</title>
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1.0, user-scalable=0, minimum-scale=1.0, maximum-scale=1.0">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.5.0/socket.io.js"></script>
    <script type="module" src="node_modules/uikit/dist/uikit.min.js"></script>
</head>
<body>
    <div class="controls" style="text-align:center;padding-top:50px;">
        <div id="whoseTurn" style="font-size:2rem;"></div>
        <button id="apply" disabled>Apply turn</button>
        <button id="restart" onclick="location.reload()" style="display: none;">Start again</button>
    </div>
    <div id="board">
        
    </div>
    <script>
        document.onreadystatechange = function () {
            if (document.readyState == "complete") {
                const applyButton = document.getElementById("apply");
                let popup = window.uikit.Popup,
                    formSwitcher = window.uikit.FormSwitchers,
                    formInput = window.uikit.FormInput,
                    roomValue,
                    playOptions = { 
                        SINGLE: "Single Player",
                        MULTIPLAYER: "Two Players"
                    },
                    socket,
                    isCreator = false,
                    applicationState = { whoseTurn:undefined, playerA:{turns:[]}, opponent:{turns:[]} },
                    gameBoard,
                    boardOverlay,
                    loadingPopup = undefined,
                    whoseTurnPopup = undefined,
                    ctxBoard,
                    ctxOverlay,
                    curX,
                    curY,
                    pressed = false,
                    selectedCell,
                    currentTurn = {},
                    gameOver = false;

                let popupContents = function() {
                    let wrapper = document.createElement('div'),
                        header = document.createElement('h1'),
                        howManyPlayers = new formSwitcher(
                            "howManyPlayers", 
                            "How many players?",
                            "radio",
                            "howMany",
                            Object.keys(playOptions).map((key) => playOptions[key])
                        ),
                        roomName = new formInput("name", "Room Name"),
                        submitButton = document.createElement("button");
                    header.innerText = "Tic-tac-toe";
                    submitButton.innerText = "Play!";
                    wrapper.style.padding = "10px";
                    howManyPlayers.wrapper.style["padding-bottom"] = "15px";
                    roomName.wrapper.style.display = "block";
                    roomName.wrapper.style["padding-bottom"] = "15px";

                    wrapper.appendChild(header);
                    wrapper.appendChild(howManyPlayers.wrapper);
                    wrapper.appendChild(roomName.wrapper);
                    howManyPlayers.values = ["Two Players"];
                    howManyPlayers.on("change", e => {
                        console.log("changed radio: ", e.target.value);
                        if (e.target.value === playOptions.SINGLE) {
                            roomName.wrapper.style.display = "none";
                        } else {
                            roomName.wrapper.style.display = "block";
                        }
                    });

                    submitButton.addEventListener("click", () => {
                        const value = howManyPlayers.values[0];
                        if(value === playOptions.SINGLE) {
                            alert("Sorry, single player game is not implemented yet! \n please choose Multiplayer one, \n and call a friend to play with you!");
                        } else {
                            if(roomName.value.trim().length === 0) {
                                alert("please type a room name to play!");
                            } else {
                                console.log("play");
                                roomValue = roomName.value.trim();
                                socket = io("https://alfa-webrtc-signaling.herokuapp.com", {withCredentials: true});
                                socket.on("created", (room, map) => {
                                    console.log("room created! Waiting for other player...");
                                    optionsPopup.close();
                                    loadingPopup = new popup("loading", loadingContents(), true);
                                    isCreator = true;
                                });
                                socket.on("joined", (room, map) => {
                                    console.log("some body joined! Starting the game!");
                                    optionsPopup.close();
                                    applicationState = map;
                                    if(loadingPopup) loadingPopup.close();
                                    console.log("whose turn: ", applicationState.whoseTurn);
                                    if(typeof applicationState.whoseTurn === "undefined") {
                                        whoseTurnPopup = new popup("whoseTurn", whoseTurnContents(), true);
                                    }
                                });
                                socket.on("log", (message) => {
                                    console.log("log from server: ", message);
                                });
                                socket.on("full", (message) => {
                                    alert("Sorry, this room is overflowed, choose another one");
                                });
                                socket.on("message", (message) => {
                                    console.log("message from server: ", message);
                                    switch(message.type) {
                                        case "who_first":
                                            if(!isCreator) { 
                                                applicationState.whoseTurn = message.whoseTurn;
                                                applicationState.playerA.type = message.whoseTurn == 1 ? "circle":  "cross";
                                                applicationState.opponent.type = message.whoseTurn == 1 ? "cross" : "circle";
                                                console.log("Player " + message.whoseTurn + ", will be first!");
                                                if(loadingPopup) loadingPopup.close();
                                                drawBoard(applicationState.whoseTurn);
                                                setTimeout(() => whoseTurnPopup.close(), 2000);
                                            }
                                        break;
                                        case "turn_pass": 
                                            console.log("received message from opponent!");
                                            console.log("new app state: ");
                                            console.log(applicationState);
                                            applicationState.whoseTurn = message.state.whoseTurn;
                                            applicationState.opponent = message.state.playerA;
                                            drawDoneTurns();
                                            writeWhoseTurnMessage(applicationState.whoseTurn);
                                            determineWinner("opponent");
                                    }
                                });
                                
                                socket.emit('create or join', roomValue, applicationState);
                            }
                        }
                    });

                    wrapper.appendChild(submitButton);
                    return wrapper;
                }
                const loadingContents = () => {
                    let wrapper = document.createElement("div"),
                        text = document.createElement("p");
                    wrapper.innerHTML = '<iframe src="https://upload.wikimedia.org/wikipedia/commons/b/b1/Loading_icon.gif" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>';
                    text.innerText = ("Waiting other player to join, please ask your friend to go to the address: " + window.location + ", and join the room: " + roomValue);
                    wrapper.appendChild(text);
                    wrapper.style.padding = "10px";
                    return wrapper;
                }
                const whoseTurnContents = () => {
                    let wrapper = document.createElement("div"),
                        text = document.createElement("p");
                    wrapper.innerHTML = '<iframe src="https://upload.wikimedia.org/wikipedia/commons/b/b1/Loading_icon.gif" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>';
                    text.innerText = ("Randomly choosing first player turn.");
                    if(isCreator) {
                        setTimeout(() => {
                            let player = ~~(Math.random() * 2) + 1;
                            console.log("Player ", player, " will be first!");
                            applicationState.playerA.type = player === 1 ? "cross" : "circle";
                            applicationState.opponent.type = player === 1 ? "circle" : "cross";
                            applicationState.whoseTurn = player;
                            socket.emit("message", {type:"who_first", whoseTurn: player});
                            drawBoard(player);
                            if(whoseTurnPopup) {
                                whoseTurnPopup.close();
                            }
                        }, 3000);
                    }
                    return wrapper;
                }

                const optionsPopup = new popup("default", popupContents(), true);  

                const drawBoard = (player) => {
                    const windowWidth = window.innerWidth,
                        windowHeight = window.innerHeight,
                        boardDiv = document.getElementById("board");

                    let boardWidth = windowWidth,
                        cellWidth = boardWidth / 3;

                    console.log("draw board");

                    writeWhoseTurnMessage(player);
                    
                    gameBoard = document.createElement("canvas");
                    turnsOverlay = document.createElement("canvas");
                    boardOverlay = document.createElement("canvas");

                    ctxBoard = gameBoard.getContext("2d");
                    ctxTurnsOverlay = turnsOverlay.getContext("2d");
                    ctxOverlay = boardOverlay.getContext("2d");
                    
                    gameBoard.id = "GameBoard";
                    turnsOverlay.id = "TurnsOverlay";
                    boardOverlay.id = "BoardOverlay";

                    if (windowWidth > windowHeight) {
                        while (boardWidth > windowHeight) {
                            boardWidth = windowWidth / 2;
                        }
                    } else {
                        boardWidth = windowHeight;
                        while (boardWidth > windowWidth) {
                            boardWidth = windowHeight / 2;
                        }
                    }

                    cellWidth = boardWidth / 3
                    gameBoard.width = boardWidth;
                    gameBoard.height = boardWidth;

                    gameBoard.style.position = "absolute";
                    gameBoard.style.left = "25%";
                    gameBoard.style.top = "25%";

                    boardOverlay.width = boardWidth;
                    boardOverlay.height = boardWidth;

                    boardOverlay.style.position = "absolute";
                    boardOverlay.style.left = "25%";
                    boardOverlay.style.top = "25%";

                    turnsOverlay.width = boardWidth;
                    turnsOverlay.height = boardWidth;

                    turnsOverlay.style.position = "absolute";
                    turnsOverlay.style.left = "25%";
                    turnsOverlay.style.top = "25%";

                    ctxBoard.fillStyle = "rgba(255, 255, 255, 0.3)";
                    ctxOverlay.fillStyle = "rgba(0, 0, 0, 0)"; 
                    ctxBoard.fillRect(0, 0, boardWidth, boardWidth);
                    ctxOverlay.fillRect(0, 0, boardWidth, boardWidth);


                    ctxBoard.strokeStyle = 'black';
                    ctxBoard.lineWidth = 5;

                    // draw a red line
                    ctxBoard.beginPath();
                    ctxBoard.moveTo(boardWidth/3, 0);
                    ctxBoard.lineTo(boardWidth/3, boardWidth);
                    ctxBoard.stroke();

                    ctxBoard.beginPath();
                    ctxBoard.moveTo(boardWidth/3 * 2, 0);
                    ctxBoard.lineTo(boardWidth/3 * 2, boardWidth);
                    ctxBoard.stroke();

                    ctxBoard.beginPath();
                    ctxBoard.moveTo(0, boardWidth/3);
                    ctxBoard.lineTo(boardWidth, boardWidth/3);
                    ctxBoard.stroke();

                    ctxBoard.beginPath();
                    ctxBoard.moveTo(0, boardWidth/3 * 2);
                    ctxBoard.lineTo(boardWidth, boardWidth/3 * 2);
                    ctxBoard.stroke();

                    boardDiv.appendChild(gameBoard);
                    boardDiv.appendChild(turnsOverlay);
                    boardDiv.appendChild(boardOverlay);

                    //setDrawEvents();

                    boardDiv.addEventListener("mousemove",  (e) => {
                        const x = e.offsetX,
    		                y = e.offsetY,
                            hoveredCellX = x > cellWidth ? x > (cellWidth * 2) ? 2 : 1 : 0,
                            hoveredCellY = y > cellWidth ? y > (cellWidth * 2) ? 2 : 1 : 0;
                        if (!isCellAlreadyOccupied(hoveredCellX, hoveredCellY)) {
                            ctxOverlay.clearRect(0, 0, boardOverlay.width, boardOverlay.height);
                            ctxOverlay.fillStyle = "rgba(189, 195, 199, 0.5)";
                            ctxOverlay.fillRect(hoveredCellX * cellWidth, hoveredCellY * cellWidth, cellWidth, cellWidth);
                        }
                    });

                    boardDiv.addEventListener("click",  (e) => {
                        const x = e.offsetX,
    		                y = e.offsetY,
                            clickedCellX = x > cellWidth ? x > (cellWidth * 2) ? 2 : 1 : 0,
                            clickedCellY = y > cellWidth ? y > (cellWidth * 2) ? 2 : 1 : 0;

                        let drawType;
                        console.log("clicked, application turn is by creator ?" , isCreator);
                        if (gameOver) {
                            message("This game has already over. Refresh your browser to start a new one.");
                            return;
                        }
                        if (whoseTurn(applicationState.whoseTurn) === "Its is your opponent turn") {
                            message("Its is your opponent turn now! Please wait...");
                        } else if (!isCellAlreadyOccupied(clickedCellX, clickedCellY)) {
                            drawType = applicationState.playerA.type;
                            console.log("now it is turn: ", drawType);
                            ctxTurnsOverlay.clearRect(0, 0, boardOverlay.width, boardOverlay.height);
                            drawSign(drawType, clickedCellX, clickedCellY, true);
                            drawDoneTurns();
                            applyButton.disabled = false;
                        }
                    });

                    drawSign = (drawType, clickedCellX, clickedCellY, playerTurn = false) => {
                        console.log("draw: ", drawType, " ", clickedCellX, " ", clickedCellY);
                        if(drawType === "circle") {
                            const centerX = clickedCellX * cellWidth + (cellWidth/2);
                            const centerY = clickedCellY * cellWidth + (cellWidth/2);
                            const radius = cellWidth/2 - 20;

                            ctxTurnsOverlay.beginPath();
                            ctxTurnsOverlay.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);
                            //ctxTurnsOverlay.fillStyle = 'transparent';
                            //ctxTurnsOverlay.fill();
                            ctxTurnsOverlay.lineWidth = 5;
                            ctxTurnsOverlay.stroke();
                            if (playerTurn) {
                                currentTurn = { x:clickedCellX, y: clickedCellY };
                            }
                        } else {
                            const padding = 30,
                                firstLineCordsA = {x: clickedCellX * cellWidth + padding, y: clickedCellY * cellWidth + padding},
                                firstLineCordsB = {x: clickedCellX * cellWidth + cellWidth - padding, y: clickedCellY * cellWidth + cellWidth - padding},
                                secondLineCordsA = {x: clickedCellX * cellWidth  + cellWidth - padding, y: clickedCellY * cellWidth + padding},
                                secondLineCordsB = {x: clickedCellX * cellWidth + padding, y: clickedCellY * cellWidth + cellWidth - padding};

                            ctxTurnsOverlay.beginPath();
                            ctxTurnsOverlay.moveTo(firstLineCordsA.x, firstLineCordsA.y);
                            ctxTurnsOverlay.lineTo(firstLineCordsB.x, firstLineCordsB.y);
                            ctxTurnsOverlay.lineWidth = 5;
                            ctxTurnsOverlay.stroke();
                            
                            ctxTurnsOverlay.beginPath();
                            ctxTurnsOverlay.moveTo(secondLineCordsA.x, secondLineCordsA.y);
                            ctxTurnsOverlay.lineTo(secondLineCordsB.x, secondLineCordsB.y);
                            ctxTurnsOverlay.lineWidth = 5;
                            ctxTurnsOverlay.stroke();
                            if (playerTurn) {
                                currentTurn = { x:clickedCellX, y: clickedCellY }; 
                            }
                        }
                        console.log("current turn: ", currentTurn);
                    }

                    drawWin = (key) => {
                        console.log("draw win, key: ", key);
                        ctxTurnsOverlay.beginPath();
                        ctxTurnsOverlay.strokeStyle = "grey";
                        switch(key) {
                            case "0x":
                                ctxTurnsOverlay.moveTo(cellWidth / 2, 20);
                                ctxTurnsOverlay.lineTo(cellWidth / 2, cellWidth * 3 - 20);
                                break;
                            case "1x":
                                ctxTurnsOverlay.moveTo(cellWidth + cellWidth / 2, 20);
                                ctxTurnsOverlay.lineTo(cellWidth + cellWidth / 2, cellWidth * 3 - 20);
                                break;
                            case "2x":
                                ctxTurnsOverlay.moveTo(cellWidth * 2 + cellWidth / 2, 20);
                                ctxTurnsOverlay.lineTo(cellWidth * 2 + cellWidth / 2, cellWidth * 3 - 20);
                                break;
                            case "0y":
                                ctxTurnsOverlay.moveTo(20, cellWidth / 2);
                                ctxTurnsOverlay.lineTo(cellWidth * 3 - 20, cellWidth / 2);
                                break;
                            case "1y":
                                ctxTurnsOverlay.moveTo(20, cellWidth + cellWidth / 2);
                                ctxTurnsOverlay.lineTo(cellWidth * 3 - 20, cellWidth + cellWidth / 2);
                                break;
                            case "2y":
                                ctxTurnsOverlay.moveTo(20, cellWidth * 2 + cellWidth / 2);
                                ctxTurnsOverlay.lineTo(cellWidth * 3 - 20, cellWidth * 2 + cellWidth / 2);
                                break;
                            case "012":
                                ctxTurnsOverlay.moveTo(cellWidth / 2, cellWidth / 2);
                                ctxTurnsOverlay.lineTo(cellWidth * 2 + cellWidth / 2, cellWidth * 2 + cellWidth / 2);
                                break;
                            case "210":
                                ctxTurnsOverlay.moveTo(cellWidth * 2 + cellWidth / 2, cellWidth / 2);
                                ctxTurnsOverlay.lineTo(cellWidth / 2, cellWidth * 2 + cellWidth / 2);
                                break;
                        }
                        ctxTurnsOverlay.lineWidth = 3;
                        ctxTurnsOverlay.stroke();
                    }
                }

                const drawDoneTurns = () => {
                    applicationState.playerA.turns.forEach((turn) => {
                        drawSign(applicationState.playerA.type, turn.x, turn.y);
                    });
                    applicationState.opponent.turns.forEach((turn) => {
                        drawSign(applicationState.opponent.type, turn.x, turn.y);
                    });
                }

                const isCellAlreadyOccupied = (x, y) => {
                    let isOccupied = false;
                    applicationState.playerA.turns.forEach((turn) => {
                        if (turn.x === x && turn.y === y) {
                            isOccupied = true;
                        }
                    });
                    applicationState.opponent.turns.forEach((turn) => {
                        if (turn.x === x && turn.y === y) {
                            isOccupied = true;
                        }
                    });
                    return isOccupied;
                }

                applyButton.addEventListener("click", () => {
                    console.log("pass turn to other player");
                    console.log(currentTurn);
                    applicationState.playerA.turns.push({x:currentTurn.x, y:currentTurn.y});
                    applicationState.whoseTurn = applicationState.whoseTurn === 1 ? 2 : 1;
                    console.log(applicationState);
                    determineWinner("you");
                    socket.emit("message", {type:"turn_pass", state: applicationState});
                    applyButton.disabled = true;
                    writeWhoseTurnMessage(applicationState.whoseTurn);
                });

                const determineWinner = (who) => {
                    if (who === "you") {
                        isWinner(applicationState.playerA.turns, who);
                    } else {
                        isWinner(applicationState.opponent.turns, who);
                    }
                }

                const isWinner = (turns, who) => {
                    let winsCount = {"0x": [], "1x":[],"2x":[], "0y": [], "1y": [], "2y":[], "012":[], "210":[]};
                    turns.forEach((turn) => {
                        switch (turn.x) {
                            case 0:
                                winsCount["0x"].push(turn.y);
                                break;
                            case 1:
                                winsCount["1x"].push(turn.y);
                                break;
                            case 2:
                                winsCount["2x"].push(turn.y);
                                break;
                        }
                        switch(turn.y) {
                            case 0:
                                winsCount["0y"].push(turn.x);
                                break;
                            case 1:
                                winsCount["1y"].push(turn.x);
                                break;
                            case 2:
                                winsCount["2y"].push(turn.x);
                                break;
                        }
                        if ((turn.x === 0 && turn.y === 0) || (turn.x === 1 && turn.y === 1) || (turn.x === 2 && turn.y ===2)) {
                            winsCount["012"].push("xy");
                        }
                        if ((turn.x === 2 && turn.y === 0) || (turn.x === 1 && turn.y === 1) || (turn.x === 0 && turn.y ===2)) {
                            winsCount["210"].push("xy");
                        }
                    });
                    Object.keys(winsCount).forEach((winKey) => {
                        if(winsCount[winKey].length === 3) {
                            drawWin(winKey);
                            if (who === "you") {
                                writeWinMessage("Congratulations, you win!");
                            } else {
                                writeWinMessage("Your opponent wins!");
                            }
                            setGameOver();
                        }
                    });
                    if(!gameOver && (applicationState.playerA.turns.length + applicationState.opponent.turns.length === 9)) {
                        writeWinMessage("Draft!");
                        setGameOver();
                    }
                }

                function whoseTurn (player) {
                    if (typeof player !== "number") {
                        console.error("wrong type on whose turn check!");
                    }
                    return player == 1 ? isCreator ? "Its your turn now" : "Its is your opponent turn" : isCreator ? "Its is your opponent turn" : "Its your turn now"; 
                }

                function writeWhoseTurnMessage(player) {
                    const whoseTurnDiv = document.getElementById("whoseTurn");

                    whoseTurnDiv.innerText = whoseTurn(player);
                } 

                function writeWinMessage(message) {
                    const whoseTurnDiv = document.getElementById("whoseTurn");

                    whoseTurnDiv.innerText = message;
                    alert(message);
                }

                function setGameOver() {
                    const restartButton = document.getElementById("restart");
                    restartButton.style.display = "inline-block";
                    gameOver = true;
                }

                function message (message) {
                    alert(message);
                }
            }
        }
    </script>
</body>